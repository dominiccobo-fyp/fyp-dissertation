\chapter{Conclusions}

We wrap up our work with an exploration of how we have managed to realise the vision, through respective goals, and ultimately conclude with a post script of the future shape the work implemented could take.

\section{Concluding on the overall solution}

To understand what has been done and where, we draw a conclusive map of the implementation effort and respective goals which have been accomplished. (Figure: \ref{table:matrixOfGoalsAndTheirImplementationEffort}). 

\begin{table}[h!]
\centering
\small
	\begin{tabular}{|p{6cm}|c|c|c|c|c|c|}
		\hline 
		& Goal 1 & Goal 1a & Goal 2 & Goal 3 & Goal 4 & Goal 5 \\ 
		\hline 
		Chapter 2 &  &  &  &  &  &  \\ 
		\hline 
		\multicolumn{7}{|c|}{Chapter 4} \\ 
		\hline 
		Iteration 1 - Architectural Plumbing &  & X & X & X &  &  \\ 
		\hline 	
		Iteration 2 - Retrieval Mechanism &  & X & X & X &  &  \\ 
		\hline 	
		Iteration 3 - Push Approach & X &  &  &  &  & X \\ 
		\hline 
		Iteration 4 - Pull Approach & X &  &  &  & X & X \\ 
		\hline 
		Iteration 5 - Modelling Developer Context & X &  & X &  & &  \\ 
		\hline 
		Iteration 6 - GitHub Work Items & X & X &  &  & X &  \\ 
		\hline 
		Iteration 7 - GitLab Work Items & X & X &  &  & X &  \\ 
		\hline 
		Iteration 8 - GitHub Experts & X & X &  &  & X &  \\ 
		\hline 
		Iteration 9 - Performance Bottlenecks &  & X &  &  & X &  \\ 
		\hline 
		Iteration 10 - StackOverflow Documentation & X & X &  &  & X &  \\ 
		\hline 
		Iteration 11 - UI Modularity &  &  & X & X &  &  \\ 
		\hline 
	\end{tabular} 
	\caption{Matrix of goals and where they are addressed}
	\label{table:matrixOfGoalsAndTheirImplementationEffort}
\end{table}

\begin{figure}[h!]
	\small
	\printGoals
	\caption{Legend of Objectives}
\end{figure}

Through the distribution of these efforts it is visible that, despite the granularity of the tasks, there has been a strong interdependency amongst iterations, each providing their little attribution to the overall vision. 

We note a dominant coverage, supported in the evaluation, to efforts associated with reducing the time taken to retrieve relevant information for a given problem context (Goal \#4). This dominance is also displayed in towards the goal of providing aggregated information based on a relevant context for multiple topics (Goal \#1). 

Throughout the ample provisioning of new topics, information sources and evaluation of the modularity do we show ease of extending this solution (Goal \#2). We further illustrate the applicability of this solution across multiple different integration points (Goal \#3). We have managed to successfully contrast the two retrieval mechanisms, highlighting both the usability and the performance implications of each (Goal \#5).

Whilst there has been coverage, it would be untrue to state that the solution itself is ideal; what has been achieved merely demonstrates the superficial feasibility of the project. No software project is ever finished. We have only shown the integration of well-documented sources in lieu of being able to source out-of-the-box tools from academia. Neither have we been able to certify the ecological validity of our findings due to circumstances outside our control.

\section{Future Work}

As with every product, that is more than just a product, there is always an ongoing maintenance job to enable it to adapt to a changing environment and requirements. This project has shown in its infancy, feasibility, but only through the production of this prototype have we realised its tangible real potential and downsides. We explore these in the upcoming sections.

\subsection{Addressing the Language Support Conundrum}

Throughout this project we have based our approach on the Microservices distributed computing paradigm, yet through rapid choice of a framework to assist productivity and provide a clear, easy integration, have we overlooked the necessity to support multiple languages.

Scripting languages are strongly preferred for data-science and mining purposes. Our choice of Axon constrains us to JVM languages which ultimately reduces the language choice to Groovy for scripting. However, R and Python are also popular in this field and are naturally not supported for execution on the JVM. 

We are however not at a dead end, whilst architectural decisions imply decisions that are hard to change in the future or being decisions that we wish we would have made correctly at the beginning, good architecture adverts this crisis. Axon permits the change of the messaging middleware, allowing us to move towards a more widely supported system such as RabbitMQ if needed. Alternatively, we could consider a polyglotic JVM, such as Graal that permits the execution of multiple different languages that are not based on the JVM.

\subsection{Response model is very inflexible}

We have been unable to collate sufficient sources to make a correctly informed decision on what shape our topic response models should take; however, at the same time it is apparent that the model could provide far more room for deviation from standard responses. 

We envision this could be realised through the definition of an extra attributes data map. These extra attributes would of course need a way of being accessed and presented within the IDE Web View that we have created, leading to extra concerns that need addressing such as the requirement of a template server where miners can optional define how they wish for their information to be presented; yet this very flexibility could lead to a confusing, inconsistent exploration experience on par with the search engine approach we were initially trying to improve.

\subsection{Truly IDE Agnostic Plugins}

The vision has focused on enabling the retrieval of information from multiple sources. However, from implementing the architecture, have we noticed the potential applicability to a wider scope of interaction with external sources.

Through evolving the integration to focus on a more integrated presentation of data, that is not just a Web View, but more dependent on the IDE itself, we could transfer the same approach to create reusable interactions across IDEs. Enabling universal, IDE agnostic plugins could have untold benefits to the development of Software Development tooling as a whole. 

This of course, presents potential to provide a plugin repository or store that allows these integrations to be used according to the preference of each individual developer.

\subsection{Enabling greater insight into Developers' Mindset}

Understanding how developers work has been the subject for decades for many in the Software Engineering field. Companies also have an interest in understanding how they can squeeze more out of their employees.

Through integration of a universal approach of retrieving information, we can begin to orchestrate telemetry for providing metrics on what developers do within their IDEs, how they search for information to solve problems and ultimately what information domains or sources are useful and which are not. 

\subsection{Expansion beyond IDEs - Word Processors}

This solution implemented has purposely focused on a vision deeply rooted in supporting Software Engineering practitioners. However, not every text-productivity task in this word is a software development; there are other productivity tasks that require constant interaction with distinct information sources. For example, word processors. Many Word processors such as Microsoft Word, Google Docs and others provide extensions, with some supporting exploration of information relating to the document (Figure: \ref{fig:google-docs-context}). 

The solution developed and the ecology of the vision is in principle transferable to the context of Word Processors.

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\linewidth]{google-docs-context}
	\caption{Illustration of Google Docs' Context Mechanism and Plugins (Right toolbar)}
	\label{fig:google-docs-context}
\end{figure}

